<!DOCTYPE html>
<html>
<head>
    {% load static %}
    <link rel="stylesheet" href="{% static 'notes/style.css' %}">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
    <script>
        pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';
    </script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.14.305/pdf_viewer.min.css">
    <style>
      #tools-panel {
        position: absolute;
        top: 10px;
        left: 10px;
        display: flex;
        flex-direction: column;
        z-index: 1000;
      }

      #tools-panel button {
        margin-bottom: 5px;
      }

      #tools-panel button.active {
        box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
        background-color: #ddd;
      }

      .highlight-box {
        position: absolute;
        background-color: rgba(255, 255, 0, 0.4);
        pointer-events: none;
      }

      .underline-line {
        position: absolute;
        background-color: black;
        pointer-events: none;
      }

      .selected-annotation {
          outline: 2px dashed red;
          background-color: rgba(0, 255, 255, 0.3);
      }

      /* Disable text selection visually */
      .no-text-select {
          user-select: none;
          -webkit-user-select: none;
          -moz-user-select: none;
          -ms-user-select: none;
      }

      /* Disable pointer events for drawing tools on the textLayer */
      .textLayer.block-events {
          pointer-events: none;
      }

      .btn {
        padding: 0.5em 1em;
        background-color: #6c63ff;
        color: white;
        border: none;
        border-radius: 6px;
        font-size: 0.95em;
        font-weight: 500;
        cursor: pointer;
        transition: background-color 0.3s ease;
      }

      .btn:hover {
        background-color: #5548d9;
      }

      .btn-icon {
        background-color: transparent;
        border: none;
        font-size: 1.2em;
        cursor: pointer;
        color: #444;
        transition: color 0.2s ease;
      }

      .btn-icon:hover {
        color: #000;
      }
    </style>
</head>
<body>
    <div style="position: absolute; top: 10px; right: 10px; z-index: 1001;">
        <a href="/" style="text-decoration: none;">
            <button class="btn">See Article List</button>
        </a>
    </div>
    <div class="container">
        <!-- LEFT: PDF Viewer -->
        <div class="pdf-viewer">
            <div id="pdf-container" style="width: 100%; height: 100%; overflow-y: auto;"></div>
        </div>

        <!-- RIGHT: Notes panel -->
        <div class="right-panel">
            <button class="btn" onclick="saveAllNotes()">Save Notes</button>
        </div>
    </div>
    
    {{ annotations|json_script:"annotation-data" }}


    <script>
        const url = "{{ article.pdf_url }}";
        const container = document.getElementById("pdf-container");

        pdfjsLib.getDocument(url).promise.then(function(pdf) {
            for (let pageNum = 1; pageNum <= pdf.numPages; pageNum++) {
                pdf.getPage(pageNum).then(function(page) {
                    const viewport = page.getViewport({ scale: 1.5 });
                
                    const pageWrapper = document.createElement("div");
                    pageWrapper.classList.add("pdf-page-wrapper");
                    pageWrapper.dataset.page = pageNum;
                    pageWrapper.style.position = "relative";
                    pageWrapper.style.marginBottom = "20px";
                
                    const canvas = document.createElement("canvas");
                    const context = canvas.getContext("2d");
                    canvas.width = viewport.width;
                    canvas.height = viewport.height;
                
                    const renderContext = {
                        canvasContext: context,
                        viewport: viewport
                    };
                
                    pageWrapper.appendChild(canvas);
                    container.appendChild(pageWrapper); // move this here
                
                    page.render(renderContext).promise.then(() => {
                        const textLayerDiv = document.createElement("div");
                        textLayerDiv.className = "textLayer";
                        textLayerDiv.style.position = "absolute";
                        textLayerDiv.style.top = "0";
                        textLayerDiv.style.left = "0";
                        textLayerDiv.style.transform = "none"; // REMOVE scale transform
                        textLayerDiv.style.height = `${viewport.height}px`;
                        textLayerDiv.style.width = `${viewport.width}px`;
                        textLayerDiv.style.zIndex = 2;
                
                        pageWrapper.appendChild(textLayerDiv);
                
                        page.getTextContent().then(function(textContent) {
                            pdfjsLib.renderTextLayer({
                                textContent: textContent,
                                container: textLayerDiv,
                                viewport: viewport,
                                textDivs: []
                            });
                        });
                    });
                
                    renderAnnotationsForPage(pageWrapper, pageNum);
                });
            }

        });

        async function getTextFromHighlightBox(pageNumber, left, top, width, height) {
            const pdf = await pdfjsLib.getDocument(url).promise;
            const page = await pdf.getPage(pageNumber);
            const viewport = page.getViewport({ scale: 1.5 });
            const textContent = await page.getTextContent();
            const items = textContent.items;
        
            const strings = [];
        
            const offsetY = 240;  // Try adjusting this up/down if needed
        
            const selectionX0 = left;
            const selectionY0 = top + offsetY;
            const selectionX1 = left + width;
            const selectionY1 = top + height + offsetY;
        
            items.forEach(item => {
                const tx = pdfjsLib.Util.transform(viewport.transform, item.transform);
                const x = tx[4];
                const y = tx[5];
                const itemWidth = item.width;
                const itemHeight = item.height;
        
                const itemX0 = x;
                const itemY0 = y - itemHeight;
                const itemX1 = x + itemWidth;
                const itemY1 = y;
        
                const overlaps = (
                    itemX0 < selectionX1 &&
                    itemX1 > selectionX0 &&
                    itemY0 < selectionY1 &&
                    itemY1 > selectionY0
                );
        
                if (overlaps) {
                    strings.push(item.str);
                }
            });
        
            return strings.join(" ");
        }

        function renderAnnotationsForPage(pageWrapper, pageNum) {
            const allAnnotations = JSON.parse(document.getElementById("annotation-data").textContent);
            console.log("[CONSOLE] ALLANNOTATIONS: ", allAnnotations);
            const annotationsForPage = allAnnotations.filter(a => a.page === pageNum);

            annotationsForPage.forEach(annotation => {
                const annotationEl = document.createElement("div");
                annotationEl.classList.add(annotation.annotation_type === "highlight-box" ? "highlight-box" : "underline-line");
                annotationEl.dataset.annotationId = annotation.id;
                annotationEl.dataset.page = annotation.page;
                annotationEl.style.left = annotation.left + "px";
                annotationEl.style.top = annotation.top + "px";
                annotationEl.style.width = annotation.width + "px";
                annotationEl.style.height = annotation.height + "px";
                annotationEl.style.position = "absolute";

                annotationEl.addEventListener("click", () => {
                    highlightPair(annotation.id.toString());
                });

                pageWrapper.appendChild(annotationEl);

                console.log("[CONSOLE] ANNOTATION.NOTE: ", annotation.note);
                if (annotation.note && (annotation.note.title !== '' || annotation.note.body !== '')) {
                    createNote(annotation.id, true, annotation.note.id, annotation.note.title, annotation.note.body, "");
                    // Attach click listener to restored note for highlightPair
                    const noteElement = document.querySelector(`.note[data-annotation-id='${annotation.id}']`);
                    if (noteElement) {
                        noteElement.addEventListener("click", () => {
                            highlightPair(annotation.id.toString());
                        });
                    }
                }
            });
        }

        function getCSRFToken() {
            const name = 'csrftoken';
            const cookies = document.cookie.split(';');
            for (let cookie of cookies) {
            const c = cookie.trim();
            if (c.startsWith(name + '=')) {
                return decodeURIComponent(c.substring(name.length + 1));
            }
            }
            return null;
        }
        
        function saveAllNotes() {
            const notes = document.querySelectorAll('.note');
            notes.forEach(note => {
                const titleInput = note.querySelector('input');
                const bodyTextarea = note.querySelector('textarea');
                const title = titleInput.value;
                const content = bodyTextarea.value;
                const annotationId = note.dataset.annotationId;
                console.log("note.dataset.noteId: ", note.dataset.noteId);

                const noteId = note.dataset.noteId || null;

                console.log("NoteId Input: ", noteId);
        
                fetch('/api/save_note/', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'X-CSRFToken': getCSRFToken()
                    },
                    body: JSON.stringify({
                        note_id: noteId,
                        annotation_id: annotationId,
                        title: title,
                        content: content,
                        article_id: parseInt("{{ article.id }}"),
                    })
                }).then(response => response.json())
                  .then(data => {
                      if (data.status !== 'error') {
                          
                          // ✅ Disable fields after successful save
                          if(title === "" && content === "") {
                              note.remove(); // Remove empty notes
                              return;
                          }
                          
                          titleInput.disabled = true;
                          bodyTextarea.disabled = true;
                          note.dataset.noteId = data.note_id; // Update with DB-assigned ID
                      } else {
                          alert("Failed to save note: " + data.message);
                      }
                  });
            });

        }

        function saveAnnotation(selectionBox) {

            const annotationData = {
                type: selectionBox.getAttribute("class"),
                article_id: parseInt("{{ article.id }}"),
                page: parseInt(selectionBox.getAttribute('data-page')),
                annotation_id: selectionBox.getAttribute('data-annotation-id'),
                left: parseFloat(selectionBox.style.left),
                top: parseFloat(selectionBox.style.top),
                width: parseFloat(selectionBox.style.width),
                height: parseFloat(selectionBox.style.height),
            };

            fetch('/api/save_annotation/', {
                method: 'POST',
                headers: {
                  'Content-Type': 'application/json',
                  'X-CSRFToken': getCSRFToken()
                },
                body: JSON.stringify(annotationData)
              })
              .then(response => response.json())
              .then(data => {
              if (data.status === 'success') {
                console.log('[CONSOLE] Annotation succcessfully saved in the database');
              } else {
                  console.log("[CONSOLE] DATA: ", data)
                  alert("Failed to save annotation: " + data.message);
              }
            });
        }

        function createNote(annotationId, EDIT_DISABLED, noteId, title = "", body = "", selectedText = "") {
            console.log("[CONSOLE] SelectedText in createNote: ", selectedText);

            const notePanel = document.querySelector(".right-panel");

            const noteDiv = document.createElement("div");
            noteDiv.classList.add("note");
            noteDiv.dataset.annotationId = annotationId;
            noteDiv.dataset.noteId = noteId;


            // Add button container for edit/delete buttons
            const buttonContainer = document.createElement("div");
            buttonContainer.style.display = "flex";
            buttonContainer.style.justifyContent = "flex-end";
            buttonContainer.style.gap = "5px";

            const deleteBtn = document.createElement("button");
            deleteBtn.textContent = "🗑️";
            deleteBtn.title = "Delete Note";
            deleteBtn.className = "btn-icon";

            deleteBtn.onclick = () => {
                // Delete note div from UI
                noteDiv.remove();
                // Delete annotation from page
                const linkedAnnotation = document.querySelector(`[data-annotation-id='${annotationId}']`);
                if (linkedAnnotation) linkedAnnotation.remove();

                // Call API to delete from database
                fetch('/api/delete_note_and_annotation/', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'X-CSRFToken': getCSRFToken()
                    },
                    body: JSON.stringify({
                        annotation_id: annotationId
                    })
                }).then(response => response.json())
                  .then(data => {
                      if (data.status !== 'deleted') {
                          alert("Failed to delete annotation/note: " + data.message);
                      }
                  });
            };

            const editBtn = document.createElement("button");
            editBtn.textContent = "✏️";
            editBtn.title = "Edit Note";
            editBtn.className = "btn-icon";
            editBtn.onclick = () => {

                EDIT_DISABLED = titleInput.disabled;

                titleInput.disabled = !EDIT_DISABLED;
                bodyTextarea.disabled = !EDIT_DISABLED;
            };

            buttonContainer.appendChild(editBtn);
            buttonContainer.appendChild(deleteBtn);
            noteDiv.appendChild(buttonContainer);

            


            const titleInput = document.createElement("input");
            titleInput.type = "text";
            titleInput.placeholder = "Title (optional)";
            titleInput.value = title;
            titleInput.disabled = EDIT_DISABLED;

            const bodyTextarea = document.createElement("textarea");
            bodyTextarea.rows = 6;
            bodyTextarea.placeholder = "Write your note here...";
            bodyTextarea.value = body;
            bodyTextarea.disabled = EDIT_DISABLED;

            if (selectedText !== "") {
                console.log("[CONSOLE] WE FINNA FETCH SUGGEST_NOTE: ", selectedText);
                titleInput.placeholder = "AI Suggestion - EDIT ME!";
                bodyTextarea.placeholder = "Hold tight! We're retrieving an AI suggestion for you... Another thing, don't hesitate to EDIT ME!";

                fetch("/api/suggest_note/", {
                    method: "POST",
                    headers: {
                        "Content-Type": "application/json",
                        "X-CSRFToken": getCSRFToken()
                    },
                    body: JSON.stringify({ selectedText: selectedText })
                })
                .then(res => res.json())
                .then(data => {
                    console.log("[CONSOLE] SUGGESTED NOTE RESPONSE: ", data);
                    if (data.status === "success") {
                        titleInput.value = data.suggestedTitle;
                        bodyTextarea.value = data.suggestedBody;
                    }
                })
                .catch(err => {
                    console.error("Failed to fetch suggested note:", err);
                });
            }


            noteDiv.appendChild(titleInput);
            noteDiv.appendChild(bodyTextarea);
            // notePanel.appendChild(noteDiv); // REMOVE: will append below

            noteDiv.style.display = "block";

            // Insert noteDiv in order based on annotation Y-offset
            const allNotes = Array.from(notePanel.querySelectorAll(".note")).filter(n => n !== noteDiv);
            const annotationElement = document.querySelector(`[data-annotation-id='${annotationId}']`);
            const newY = annotationElement?.getBoundingClientRect().top || 0;
            let inserted = false;
            for (let existingNote of allNotes) {
                const otherAnnotationId = existingNote.dataset.annotationId;
                const otherAnnotation = document.querySelector(`[data-annotation-id='${otherAnnotationId}']`);
                if (otherAnnotation?.getBoundingClientRect().top > newY) {
                    notePanel.insertBefore(noteDiv, existingNote);
                    inserted = true;
                    break;
                }
            }
            if (!inserted) notePanel.appendChild(noteDiv);

            // Link back to annotation
            noteDiv.addEventListener("click", () => {
                highlightPair(annotationId);
            });

            // Also link annotation → note (to ensure reload & new pairs work both ways)
            const linkedAnnotation = document.querySelector(`[data-annotation-id='${annotationId}']`);
            if (linkedAnnotation) {
                linkedAnnotation.addEventListener("click", () => {
                    highlightPair(annotationId);
                });
            }
        }

        function highlightPair(annotationId) {
            document.querySelectorAll(".highlight-box, .underline-line").forEach(el => {
                if (el.dataset.annotationId === annotationId) {
                    el.classList.add("selected-annotation");
                } else {
                    el.classList.remove("selected-annotation");
                }
            });

            document.querySelectorAll(".note").forEach(note => {
                if (note.dataset.annotationId === annotationId) {
                    note.classList.add("selected-annotation");
                } else {
                    note.classList.remove("selected-annotation");
                }
            });
        }
    </script>
</body>
    <!-- Tools Panel -->
    <div id="tools-panel">
        <button id="highlight-btn" class="btn">Highlight</button>
        <button id="underline-btn" class="btn">Underline</button>
        <button id="erase-btn" class="btn">Erase</button>
    </div>

    <script>
        let tool = null;
        const buttons = document.querySelectorAll("#tools-panel button");
        function setTool(selectedTool, buttonId) {
            tool = selectedTool;
            buttons.forEach(btn => btn.classList.remove("active"));
            document.getElementById(buttonId).classList.add("active");

            // Toggle text selection and pointer events for textLayer
            const textLayers = document.querySelectorAll(".textLayer");
            textLayers.forEach(layer => {
                if (tool === "highlight" || tool === "underline") {
                    layer.classList.add("no-text-select", "block-events");
                } else {
                    layer.classList.remove("no-text-select", "block-events");
                }
            });
        }

        document.getElementById("highlight-btn").onclick = () => setTool("highlight", "highlight-btn");
        document.getElementById("underline-btn").onclick = () => setTool("underline", "underline-btn");
        document.getElementById("erase-btn").onclick = () => setTool("erase", "erase-btn");

        const pdfContainer = document.getElementById("pdf-container");

        pdfContainer.addEventListener("mousedown", startSelection);
        let startX, startY, selectionBox;

        let actionHistory = [];
        let redoStack = [];

        function saveAction(element) {
            actionHistory.push(element);
            redoStack = [];
        }

        function undoAction() {
            if (actionHistory.length === 0) return;
            const last = actionHistory.pop();
            if (last) {
                redoStack.push(last);
                last.remove();
            }
        }

        function redoAction() {
            if (redoStack.length === 0) return;
            const last = redoStack.pop();
            if (last) {
                const { element, parent, page } = last;
                actionHistory.push(element);
                const wrapper = document.querySelector(`.pdf-page-wrapper[data-page='${page}']`);
                if (wrapper) wrapper.appendChild(element);
            }
        }

        // Add keyboard shortcuts
        document.addEventListener("keydown", (e) => {
            if ((e.ctrlKey || e.metaKey) && e.key.toLowerCase() === "z") {
                if (e.shiftKey) {
                    e.preventDefault();
                    redoAction();
                } else {
                    e.preventDefault();
                    undoAction();
                }
            }
        });

        function startSelection(e) {
            console.debug("DEBUG: In startSelection.");

            if (!tool) return;
            e.preventDefault();

            if (tool === "erase") {
                document.querySelectorAll(".highlight-box, .underline-line").forEach(el => el.classList.remove("selected-annotation"));
                const wrapper = e.target.closest(".pdf-page-wrapper");
                if (!wrapper) return;

                const wrapperRect = wrapper.getBoundingClientRect();
                const x = e.clientX - wrapperRect.left;
                const y = e.clientY - wrapperRect.top;

                const children = Array.from(wrapper.children);
                for (let i = children.length - 1; i >= 0; i--) {
                    const el = children[i];
                    if (el.classList.contains("highlight-box") || el.classList.contains("underline-line")) {
                        const elRect = el.getBoundingClientRect();
                        const relX = e.clientX - elRect.left;
                        const relY = e.clientY - elRect.top;
                        const margin = 10;
                        if (relX >= -margin && relX <= elRect.width + margin && relY >= -margin && relY <= elRect.height + margin) {
                            el.classList.add("selected-annotation");
                            setTimeout(() => {
                            const parent = el.parentNode;
                            const pageNum = el.dataset.page;
                            el.remove();

                            // Begin: API call to delete annotation/note
                            const annotationId = el.dataset.annotationId;

                            const noteElement = document.querySelector(`.note[data-annotation-id='${annotationId}']`);
                            console.log("[CONSOLE] NOTE ELEMENT: ", noteElement);
                            if (noteElement) {
                                noteElement.remove();
                            }

                            fetch('/api/delete_note_and_annotation/', {
                                method: 'POST',
                                headers: {
                                    'Content-Type': 'application/json',
                                    'X-CSRFToken': getCSRFToken()
                                },
                                body: JSON.stringify({ annotation_id: annotationId })
                            }).then(response => response.json())
                            .then(data => {
                                if (data.status !== 'deleted') {
                                    alert("Failed to delete annotation/note: " + data.message);
                                }
                            });
                            // End: API call
                            actionHistory = actionHistory.filter(a => a !== el);
                            redoStack = []; // clear redo on new action
                            redoStack.push({ element: el, parent: parent, page: pageNum });
                            }, 200);
                            return;
                        }
                    }
                }
                return;
            }

            // New logic to distinguish between click (select) and drag (create annotation)
            const targetWrapper = e.target.closest(".pdf-page-wrapper");
            if (!targetWrapper) return;

            const clickThreshold = 5;
            const initialX = e.clientX;
            const initialY = e.clientY;

            function onMouseMove(moveEvent) {
                const dx = moveEvent.clientX - initialX;
                const dy = moveEvent.clientY - initialY;
                if (Math.abs(dx) > clickThreshold || Math.abs(dy) > clickThreshold) {
                    document.removeEventListener("mousemove", onMouseMove);
                    document.removeEventListener("mouseup", onMouseUp);
                    beginAnnotation(e, targetWrapper);
                }
            }

            function onMouseUp(upEvent) {
                console.debug("DEBUG: In onMouseUp.");

                document.removeEventListener("mousemove", onMouseMove);
                document.removeEventListener("mouseup", onMouseUp);

                // Perform selection if it's a simple click
                const x = upEvent.clientX - targetWrapper.getBoundingClientRect().left;
                const y = upEvent.clientY - targetWrapper.getBoundingClientRect().top;

                const children = Array.from(targetWrapper.children);
                for (let i = children.length - 1; i >= 0; i--) {
                    const el = children[i];
                    if (el.classList.contains("highlight-box") || el.classList.contains("underline-line")) {
                        const elRect = el.getBoundingClientRect();
                        const relX = upEvent.clientX - elRect.left;
                        const relY = upEvent.clientY - elRect.top;
                        const margin = 10;
                        if (relX >= -margin && relX <= elRect.width + margin && relY >= -margin && relY <= elRect.height + margin) {
                            highlightPair(el.dataset.annotationId);
                            return;
                        }
                    }
                }
            }

            document.addEventListener("mousemove", onMouseMove);
            document.addEventListener("mouseup", onMouseUp);
        }

        function beginAnnotation(e, targetWrapper) {
            startX = e.offsetX;
            startY = e.offsetY;

            selectionBox = document.createElement("div");
            selectionBox.classList.add(tool === "highlight" ? "highlight-box" : "underline-line");
            selectionBox.style.left = `${startX}px`;
            selectionBox.style.top = `${startY}px`;
            selectionBox.dataset.page = targetWrapper.dataset.page;
            targetWrapper.appendChild(selectionBox);
            saveAction(selectionBox);

            pdfContainer.addEventListener("mousemove", updateSelection);
            pdfContainer.addEventListener("mouseup", endSelection);
        }

        function updateSelection(e) {
            console.debug("DEBUG: In updateSelection.");

            if (!selectionBox) return;
            const targetWrapper = e.target.closest(".pdf-page-wrapper");
            if (!targetWrapper) return;

            const rect = targetWrapper.getBoundingClientRect();
            const currentX = e.clientX - rect.left;
            const currentY = e.clientY - rect.top;

            const width = currentX - startX;
            const height = currentY - startY;

            if (tool === "highlight") {
                selectionBox.style.width = `${Math.abs(width)}px`;
                selectionBox.style.height = `${Math.abs(height)}px`;
                selectionBox.style.left = `${Math.min(startX, currentX)}px`;
                selectionBox.style.top = `${Math.min(startY, currentY)}px`;
            } 
            else if (tool === "underline") {
                    selectionBox.style.width = `${Math.abs(width)}px`;
                    selectionBox.style.height = `2px`;
                    selectionBox.style.left = `${Math.min(startX, currentX)}px`;
                    selectionBox.style.top = `${Math.min(startY, currentY)}px`;  // ✅ This line is missing in your code
                }
        }

        function endSelection() {
            let selectedText = "";
            console.debug("DEBUG: In endSelection.");

            pdfContainer.removeEventListener("mousemove", updateSelection);
            pdfContainer.removeEventListener("mouseup", endSelection);
            document.querySelectorAll(".highlight-box, .underline-line").forEach(el => el.classList.remove("selected-annotation"));

            if (tool === "highlight" || tool === "underline") {
                // const annotationId = `annotation-${Date.now()}`;
                const annotationId = Date.now();
                if (selectionBox) {
                    selectionBox.dataset.annotationId = annotationId;
                    console.log("Selection box: ", selectionBox)
                    
                    // Add click-to-select on annotation
                    selectionBox.addEventListener("click", () => {
                        highlightPair(annotationId);
                    });
                }
                try {
                    console.debug("CONSOLE: before createNote is defined. Proceeding to call it.");
                    saveAnnotation(selectionBox);

                    if (tool === "highlight") {
                        const pageNum = parseInt(selectionBox.dataset.page);
                        const left = parseFloat(selectionBox.style.left);
                        const top = parseFloat(selectionBox.style.top);
                        const width = parseFloat(selectionBox.style.width);
                        const height = parseFloat(selectionBox.style.height);
                    
                        getTextFromHighlightBox(pageNum, left, top, width, height).then(result => {
                            selectedText = result;
                            console.log("[Extracted Text from Highlight Box]:", selectedText);
                            createNote(annotationId, false, null, "", "", selectedText);
                        }) .catch(err => {
                            console.error("Failed to extract text:", err);
                            createNote(annotationId, false, null, "", "", ""); // fallback
                          });
                    } else {
                        createNote(annotationId, false, null, "", "", ""); // fallback
                    }    
                    console.debug("CONSOLE: createNote is defined. Proceeding to call it.");
                } catch (e) {
                    console.error("createNote is not defined or threw an error:", e);
                    alert("Note creation failed. Check if 'createNote' is defined.");
                }
            }

            selectionBox = null;
        }
    </script>
</html>